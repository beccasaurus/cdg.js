<!DOCTYPE>
<html>
  <head>
    <title>CD+G Rendering Prototype</title>
  </head>
  <body>
    <input type="file" id="cdg-file" /><br />
    <canvas id="cdg-canvas" width="294" height="204" style="border: 1px solid black;"></canvas>
    <pre>
      [X] renderNextTile() - go through and find the next tile and puts its pixel indices in the right places
          [X] put indices into array on Normal tile
          [_] put XOR into array on XOR Tile
      [X] Update to also load color table
      [X] DRAW
      [X] track second array of index:RGB color
      [_] renderNextTiles(N) - render the next X tiles
      ...
      
      For now IGNORE BORDER and only render displayable area
    </pre>
    <script>
      // globals
      var display_width = 294;
      var display_height = 204;
      var tiles_per_row = 6;
      var tiles_per_column = 4;
      var tile_width = display_width / tiles_per_row;
      var tile_height = display_height / tiles_per_column;
      var pixelColorIndices = {}; // for now, store { [x,y] => colorIndex } // TODO optimize
      var pixelColors = {}; // for now, store { [x,y] => RGB } // TODO optimize
      var dirtyPixels = [];
      var arrayBuffer = null;
      var packetsRead = 0;
      var colorTable = {}; // 0-15 => color (bytes or rgb?)

      var readFile = function() {
        var reader = new FileReader();
        reader.onload = function(e) {
          window.arrayBuffer = reader.result;
          window.packetsRead = 0;
        };
        var selectedFile = document.getElementById("cdg-file").files[0];
        reader.readAsArrayBuffer(selectedFile);
      }

      var loadColorTable = function(packet, offset){
        for (var i = 0; i < 8; i++) {
          var color = (packet.data[2 * i] & 0x3F) << 8
          color = (packet.data[(2 * i) + 1] & 0x3F)
          color = ((color & 0x3F00) >> 2) | (color & 0x003F)

          red = ((color & 0x0F00) >> 8) * 17 // why 17 not 16 ... coming through as 0 in most cases ... (try other cdg)
          green = ((color & 0x00F0) >> 4) * 17
          blue = ((color & 0x000F)) * 17
          
          window.colorTable[i + offset] = [red, green, blue];
        }
      };

      var minX = 9999;
      var minY = 9999;
      var maxX = 0;
      var maxY = 0;
      var canvas = document.getElementById("cdg-canvas");
      var canvasContext = canvas.getContext("2d");
      var draw = function() {
        for (var i in window.dirtyPixels) {
          var pixelKey = window.dirtyPixels[i];
          var xy = pixelFromKey(pixelKey);
          var x = xy[0];
          var y = xy[1];
          var rgb = window.pixelColors[pixelKey];
          if (! rgb) {
            console.log("Couldn't find pixel color for key: " + pixelKey);
          }
          var rgbString = "rgb(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ")";
          canvasContext.fillStyle = rgbString;
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
          canvasContext.fillRect(x, y, 1, 1);
        }
        canvasContext.save();
        window.dirtyPixels = [];
      };

      var processNextPacket = function() {
        var packet = getNextPacket();
        switch (packet.instruction) {
          case 1: setScreenColor(packet); break;
          case 6: processTilePacket(packet); break;
          case 30: loadColorTable(packet, 0); break;
          case 31: loadColorTable(packet, 8); break;
          case 38: processTilePacket(packet, true);
          default: break;
        };
      };

      var processPackets = function(n) {
        for (var i = 0; i < n; i++)
          processNextPacket();
        draw();
      };

      var processTilePacket = function(packet, xor) {
        // process Normal Tile
        var color0 = packet.data[0] & 0x0F;
        var color1 = packet.data[1] & 0x0F;
        var row = packet.data[2] & 0x1F;
        var column = packet.data[3] & 0x3F;

        // process tiles and add to pixelColorIndices
        // These commands load a 12 x 6 tile of pixels ...
        var pixelBytes = packet.data.subarray(4, 16) // 12 bytes;
        for (var i = 0; i < pixelBytes.byteLength; i++) {
          var tileByte = pixelBytes[i] & 0x3F
          for (var j = 0; j < 6; j++) { // 6 pixels per byte
            var pixelColorChoiceByte = (tileByte >> (5 - j)) & 0x01;
            var pixelColorIndex = pixelColorChoiceByte == 0 ? color0 : color1;
            if (xor) {
              pixelColorIndex = window.pixelColorIndices[pixelColorIndex] ^ pixelColorIndex;
            }
            // http://jbum.com/cdg_revealed.html
            // Row and Column describe the position of the tile in tile coordinate space.
            // To convert to pixels, multiply row by 12, and column by 6.
            var rowPixel = row * 12;
            var columnPixel = column * 6;
            // TODO for 12x6 we need to add column/row +1 ...
            // var tiles_per_row = 6;
            // var tiles_per_column = 4;
            // assuming ... width > height ... 12 bytes > 6 per ... 12 is W 6 is H
            // console.log(["pixel", columnPixel + i, rowPixel + j, window.colorTable[pixelColorIndex]]);
            var pixelKey = keyForPixel(columnPixel + i, rowPixel + j);
            // console.log([pixelKey, columnPixel + i, rowPixel + j]);
            window.pixelColorIndices[pixelKey] = pixelColorIndex;
            window.pixelColors[pixelKey] = window.colorTable[pixelColorIndex];
            window.dirtyPixels.push(pixelKey);
          }
        }
      };

      var lastScreenColorIndex = null;
      var setScreenColor = function(packet) {
        var colorIndex = packet[0] & 0x0F;
        if (lastScreenColorIndex != colorIndex) {
          lastScreenColorIndex = colorIndex;
          var rgb = window.colorTable[colorIndex];
          if (! rgb) {
            console.log("colorTable has no index: " + colorIndex);
            return;
          }
          var rgbString = "rgb(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ")";
          canvasContext.fillStyle = rgbString;
          canvasContext.fillRect(0, 0, canvas.width, canvas.height);
          canvasContext.save();
        }
      };

      // can only store strings as keys, so use this to grab x & y for now ... can optimize later ... will use array to store * values instead of map
      var keyForPixel = function(x, y) {
        return (x * 1000) + y;
      };

      var pixelFromKey = function(key) {
        var x = parseInt(key / 1000);
        var y = key % 1000;
        return [x, y];
      };

      // CD+G packet parsing
      var getNextPacket = function() {
        var packetBytes = new Uint8Array(arrayBuffer, window.packetsRead * 24, 24)
        window.packetsRead++;
        return {
          command: packetBytes[0] & 0x3F,
          instruction: packetBytes[1] & 0x3F,
          data: packetBytes.subarray(4, 20) // 16 bytes
        };
      }
    </script>
  </body>
</html>
