<!DOCTYPE>
<html>
  <head>
    <title>CD+G Rendering Prototype</title>
  </head>
  <body>
    <input type="file" id="cdg-file" /><br />
    <canvas id="cdg-canvas" width="294" height="204" style="border: 1px solid black;"></canvas>
    <pre>
      [_] renderNextTile() - go through and find the next tile and puts its pixel indices in the right places
          [_] put indices into array on Normal tile
          [_] put XOR into array on XOR Tile
      [_] Update to also load color table
      [_] DRAW
      [_] track second array of index:RGB color
      [_] renderNextTiles(N) - render the next X tiles
      ...
      
      For now IGNORE BORDER and only render displayable area
    </pre>
    <script>
      // globals
      var display_width = 294;
      var display_height = 204;
      var tiles_per_row = 6;
      var tiles_per_column = 4;
      var tile_width = display_width / tiles_per_row;
      var tile_height = display_height / tiles_per_column;
      var pixelColorIndices = {}; // for now, store { [x,y] => colorIndex } // TODO optimize
      // var pixelColors = {}; // for now, store { [x,y] => RGB } // TODO optimize
      var arrayBuffer = null;
      var packetsRead = 0;

      var readFile = function() {
        var reader = new FileReader();
        reader.onload = function(e) {
          console.log("onload");
          window.arrayBuffer = reader.result;
          window.packetsRead = 0;
          console.log("Read file into ArrayBuffer");
          console.log(window.arrayBuffer);
        };
        var selectedFile = document.getElementById("cdg-file").files[0];
        reader.readAsArrayBuffer(selectedFile);
      }

      // render tile functions
      var renderNextTile = function() {
        var packet = getNextPacket();
        while (packet.instruction != 6) { // only get Normal Tiles for now
          packet = getNextPacket();
        }
        console.log("Next tile packet:");
        console.log(packet);

        // process Normal Tile
        var color0 = packet.data[0] & 0x0F;
        var color1 = packet.data[1] & 0x0F;
        var row = packet.data[2] & 0x1F;
        var column = packet.data[3] & 0x3F;

        // process tiles and add to pixelColorIndices
        // These commands load a 12 x 6 tile of pixels ...
        var pixelBytes = packet.data.subarray(4, 16) // 12 bytes;
        for (var i = 0; i < pixelBytes.byteLength; i++) {
          var tileByte = pixelBytes[i] & 0x3F
          for (var j = 0; i < 6; i++) { // 6 pixels per byte
            var pixelColorChoiceByte = (tileByte >> (5 - j)) & 0x01;
            var pixelColorIndex = pixelColorChoiceByte == 0 ? color0 : color1;
            // http://jbum.com/cdg_revealed.html
            // Row and Column describe the position of the tile in tile coordinate space.
            // To convert to pixels, multiply row by 12, and column by 6.
            var rowPixel = row * 12;
            var columnPixel = column * 6;
            // TODO for 12x6 we need to add column/row +1 ...
            // var tiles_per_row = 6;
            // var tiles_per_column = 4;
            // assuming ... width > height ... 12 bytes > 6 per ... 12 is W 6 is H
            window.pixelColorIndices[[columnPixel + i, rowPixel + j]] = pixelColorIndex;
            console.log("X,Y " + (columnPixel + i) + "," + (rowPixel + j) + " color: " + pixelColorIndex);
          }
        }
      };

      // CD+G packet parsing
      var getNextPacket = function() {
        var packetBytes = new Uint8Array(arrayBuffer, window.packetsRead * 24, 24)
        window.packetsRead++;
        return {
          command: packetBytes[0] & 0x3F,
          instruction: packetBytes[1] & 0x3F,
          data: packetBytes.subarray(4, 20) // 16 bytes
        };
      }
    </script>
  </body>
</html>
