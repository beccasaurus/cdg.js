<!DOCTYPE>
<html>
  <head>
    <title>cdg.js prototype</title>
    <script src="lib/cdg.js"></script>
  </head>
  <body>

    <!-- For prototyping, use input field to set .CDG -->
    <input type="file" id="upload-field" />

    <!-- canvas for rendering graphics -->
    <!--
      Full size: 300 x 216
      Display field (middle for TV): 294 x 204
      Border is displayed around display for TV
      The viewable area of the screen (294x204) is divided into 24 tiles (6x4 of 49x51 each)
    -->
    <canvas id="display" width="300" height="216" style="border: 1px solid black;"></canvas>

    <!-- render the color table for debugging -->
    <style>
      #color-table div {
        height: 20px;
        width: 20px;
        margin-right: 1px;
        border: 1px solid black;
        display: inline-block;
        font-size: 10px;
      }
    </style>
    <div id="color-table">
      <div id="color1">1</div>
      <div id="color2">2</div>
      <div id="color3">3</div>
      <div id="color4">4</div>
      <div id="color5">5</div>
      <div id="color6">6</div>
      <div id="color7">7</div>
      <div id="color8">8</div>
      <div id="color9">9</div>
      <div id="color10">10</div>
      <div id="color11">11</div>
      <div id="color12">12</div>
      <div id="color13">13</div>
      <div id="color14">14</div>
      <div id="color15">15</div>
      <div id="color16">16</div>
    </div>

    <audio id="audio"></audio>

    <!-- pre field to print debug output -->
    <pre id="debug-output"></pre>

    <script>
      // Print parsed commands to <pre> when file input is updated
      window.onload = function() {
        var uploadField = document.getElementById("upload-field");
        var debugOutput = document.getElementById("debug-output");
        var canvas = document.getElementById("display");
        var audio = document.getElementById("audio");

        window.theCanvas = canvas;
        window.theAudio = audio;

        uploadField.addEventListener("change", function(e) {
          var cdg = new CDG();
          var packetLimit = 2000; // only print some packets
          // TODO it might not be a "packet" concept we want to return ... 
          // it's likely that we'll have / I'll want:
          //  - low-level pure CDG (needs to exist to provide higher-level simple interface for <canvas>)
          //  - higher-level callbacks per packet ??? don't focus on ...
          //  - something ideal to use to render a <canvas> ... this design will sort itself out
          cdg.onPacket = function(packet) {
            if (packetLimit == 0) return;
            // debugOutput.textContent = debugOutput.textContent + JSON.stringify(packet) + "\n";
            if (packet.colorTable) {
              console.log(packet.colorTable);
              for (var colorIndex in packet.colorTable) {
                var colorElementId = "color" + (parseInt(colorIndex) + 1);
                var rgb = packet.colorTable[colorIndex]
                var rgbColor = "rgb(" + rgb[0] + "," + rgb[1] + "," + rgb[2] + ")";
                console.log("update " + colorElementId + " to " + rgbColor);
                document.getElementById(colorElementId).style.backgroundColor = rgbColor;
              }
            }
            packetLimit--;
          };

          window.currentFile = uploadField.files[0];
          cdg.loadFile(uploadField.files[0]);
        });
      };

      // load file input into audio[src] as data URL (base64 encoded)
      function loadMp3() {
        // miroseconds: theAudio.currentTime * 1000000
        var reader = new FileReader();
        reader.onload = function(e) {
          window.theAudio.src = e.target.result;
        };
        reader.readAsDataURL(window.currentFile);
      }

      // new FileReader().readAsDataURL(document.getElementById("upload-field").files[0])
    </script>
  </body>
</html>
